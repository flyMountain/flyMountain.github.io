---
layout: post
title: "Android 一天一题"
date: 2017-12-09
description: "Android 一天一题"
tag: Android面试
---

### 1、类的加载过程，Person person = new Person();为例进行说明
1. 因为new用到了Person.class,所以会先找到Person.class,并加载到内存中
2. 执行类中的static代码块，如果有的话给Person.class 进行初始化
3. 在堆内存中开辟空间分配内存地址
4. 在堆内存中建立对象的特有属性，并进行默认初始化
5. 对属性进行显示初始化
6. 对对象进行构造代码块初始化
7. 对对象进行与之相对应的构造函数进行初始化
8. 将内存地址赋给栈内存的p变量

### 2.集合框架，list，map，set都有哪些具体的实现类，区别都是什么
1. list是有序存储，可放入重复的元素
2. set是无序存储（是按照元素的Hashcode进行排序），不可放入重复的元素
3. 在增删查三个方面，list查询比较快（list是数组结构）set删除和插入比较快
4. Map适合储存键值对数据

### 3.ArrayList 和 Hashmap 简单说一些,区别,底层的数据结构
1. ArrayList是基于动态数组的数据结构，数据地址是连续，数据的查询比较快，但是数据的插入，删除（除了最后一个数据）效率比较低
2. Hashmap是基于哈希表实现的，使用的是动态数组加链表结构，先根据key值的hashCode值，确定数组的位置 然后在放在链表中。负载因子的作用是确定什么时候扩容，Hashmap默认数组长度16 负载因子默认0.75

### 4.Handler 消息机制
按照代码的习惯说一下流程
1. handler通过sendMessage()方法或者其他的setXXX()方法调用handler中的enqueueMessage()方法向MessageQueue插入一条消息同时会把本事的handler通过msg.target = this传入
2. Looper 是一个死循环，不断的读取MessageQueue中的消息，Looper会调用MessageQueue的next方法获取新消息，next是一个阻塞操作，当没有消息时next方法一直阻塞，导致Looper也一直阻塞
3. 当有消息时会回调handler的dispatchMessage()方法

### 5. 引起内存泄漏的场景
1. 资源对象没关闭
2. bitmap对象不在使用时调用recycle()释放
3. 构造Adapter时没有使用convertView
4. 注册没取消造成的内存泄漏（evenBus,service）
5. 单例造成的内存泄漏
6. 查找内存泄漏可以使用Android Studio自带的Android Profiler

### 6. 多线程的使用场景
1. App中的耗时操作，比如网络请求，文件操作
2. 为了加快App启动 可以把数据存储操作放在线程中

### 7.常见线程池
1. FixThreadPool:只有核心线程，并且数量固定，也不会被回收，所有线程都活动时，新任务会等待执行，优点是响应速度快
2. SingleThreadPool:只有一个核心线程，确保所有的任务都在同一线程中顺序操作，因此不需要处理线程同步的问题
3. CachedThreadPool:只有非核心线程，最大数量非常大，所有线程都活动时，会为新任务创建新线程，否则会利用空闲线程（60s空闲线程会被回收，所以线程池中有0个线程的可能）处理任务
4. ScheduledThreadPool:核心线程数固定，非核心线程（闲这的时候会被回收）数没有数量限制。优点：执行定时任务以及有固定周期重复任务