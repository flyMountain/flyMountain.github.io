---
layout: post
title: "普里姆（Prim）算法Java版"
date: 2017-10-10
description: "算法，java"
tag: 博客
---

### 普里姆（Prim）算法
普里姆算法是图论中的一种算法，可在加权连通图里搜索最小生成树。
举个例子来说就是要在v0 - v8 9个村子中架设电缆下图是每个村庄之间的距离
![](/Users/yuanfei/Documents/工作/客拉拉/普里姆1.jpg)

普里姆算法的作用就是让线路连线的公里数最少。



如图所示一共有九个顶点，构建如下图所示的二维数组 数组中我们使用65535代表无穷

![](/Users/yuanfei/Documents/工作/客拉拉/普里姆2.png)



`

	1. 	 /**
	2.      * 普利姆算法
	3.      */
	4.     public void prim(){
	5.         int i,j,k;
	6.         int adjvex[] = new int[9];
	7.         int lowcost[] = new int[9];
	8.         int min[] = new int[9];//最小路径数组
	9.         lowcost[0] = 0;//等于0 表示此点的权值已经确定
	10.         adjvex[0] = 0;
	11.
	12.         /**
	13.          * 循环除下标为0外的全部顶点
	14.          */
	15.         for (i = 1;i<G.length;i++){
	16.             lowcost[i] = G[0][i];
	17.             adjvex[i] = 0;
	18.         }
	19.         /**
	20.          * 循环整个过程构造最小生成树 即最小距离
	21.          */
	22.         for (i = 1;i<G.length;i++){
	23.             min[i] = 1234;
	24.             j = 1;k = 0;
	25.             /**
	26.              * 取 顶点K的最小权值   即与顶点K连接的最小距离
	27.              */
	28.             while (j<G.length){
	29.                 if (lowcost[j] !=0&&lowcost[j]<min[i]){
	30.                     min[i] = lowcost[j];
	31.                     k = j;
	32.                 }
	33.                 j++;
	34.             }
	35.
	36.             System.out.println(adjvex[k]+"         "+k);
	37.             lowcost[k] = 0; //顶点K的权值已确定
	38.
	39.             for (j = 1;j<G.length;j++){
	40.                 if (lowcost[j]!=0&&G[k][j]<lowcost[j]){
	41.                     lowcost[j] = G[k][j];
	42.                     adjvex[j] = k;
	43.                 }
	44.             }
	45.         }
	46.         for (int m = 0;m<min.length;m++){
	47.             System.out.println(min[m]+"         ");
	48.
	49.         }
   	50.}`



